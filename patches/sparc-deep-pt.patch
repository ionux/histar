Index: kern/arch/sparc/init.c
===================================================================
--- kern/arch/sparc/init.c	(revision 6971)
+++ kern/arch/sparc/init.c	(working copy)
@@ -17,14 +17,6 @@
 char boot_cmdline[256];
 
 static void
-mmu_init(void)
-{
-    for (uint32_t i = 64; i < 128; i++)
-	bootpt.pm1_ent[i] = 0;
-    tlb_flush_all();
-}
-
-static void
 bss_init (void)
 {
     extern char sbss[], ebss[];
@@ -34,8 +26,8 @@
 void __attribute__((noreturn))
 init (void)
 {
-    mmu_init();
     bss_init();
+    mmu_init();
 
     amba_init();
     irqmp_init();
Index: kern/arch/sparc/memlayout.h
===================================================================
--- kern/arch/sparc/memlayout.h	(revision 6971)
+++ kern/arch/sparc/memlayout.h	(working copy)
@@ -29,26 +29,26 @@
  */
 #define AHBPNPIO        0xF0000000
 #define AHBBASE         0xE0000000
-#define PHYSBASE	0x80000000
-#define PHYSEND         (PHYSBASE + 0x40000000)
+#define PHYSBASE	0x40000000
+#define PHYSEND         ((uintptr_t) PHYSBASE + 0x40000000)
 #define KERNBASE	PHYSBASE
 
-#define ULIM		0x80000000
+#define ULIM		0x40000000
 
 /* User-mode (below ULIM) address space layout conventions. */
 #define USTACKTOP	ULIM
 #define UTRAPMASKED     0x3FFFD000 /* keep syncrhonized with */
 #define UWINOVERFLOW    0x3FFFE000 /* lib/sparc/Makefrag     */
 #define UWINUNDERFLOW   0x3FFFF000 /*                        */
-#define UMMAPBASE	0x40000000
-#define UHEAP		0x50000000
-#define UHEAPTOP	0x60000000
-#define USTARTENVRO	0x60001000
-#define UTLSBASE	0x60002000
-#define UTLSTOP		0x60fff000
-#define UFDBASE		0x61000000
-#define USEGMAPENTS	0x62000000
-#define ULDSO		0x63000000
+#define UMMAPBASE	0x20000000
+#define UHEAP		0x30000000
+#define UHEAPTOP	0x38000000
+#define USTARTENVRO	0x38001000
+#define UTLSBASE	0x38002000
+#define UTLSTOP		0x38fff000
+#define UFDBASE		0x39000000
+#define USEGMAPENTS	0x3a000000
+#define ULDSO		0x3b000000
 
 /* libgcc code for stack unwinding uses lots of stack space... */
 #define UTLS_DEFSIZE	(2 * PGSIZE)
Index: kern/arch/sparc/pmap.c
===================================================================
--- kern/arch/sparc/pmap.c	(revision 6971)
+++ kern/arch/sparc/pmap.c	(working copy)
@@ -5,6 +5,13 @@
 #include <inc/error.h>
 #include <inc/safeint.h>
 
+static struct Contexttable bootct
+    __attribute__ ((aligned (4096), section (".data")));
+static struct Pagemap bootpt
+    __attribute__ ((aligned (4096), section (".data")));
+static struct Pagemap2 bootpt2s[192 * (1 + 64)]
+    __attribute__ ((aligned (512), section (".data")));
+
 static int
 pmap_alloc_pmap2(struct Pagemap2fl *fl, struct Pagemap2 **pgmap)
 {
@@ -337,14 +344,8 @@
 void *
 pa2kva(physaddr_t pa)
 {
-    if (pa >= PA_MEMBASE && pa < PA_MEMEND)
-	return (void *) (pa + LOAD_OFFSET);
-    
-    if (pa >= PA_AHBBASE && pa < PA_AHBEND)
-	return (void *)(AHBBASE + (pa - PA_AHBBASE));
-
-    if (pa > PA_AHBIO)
-	return (void *)pa;
+    if (pa >= PA_MEMBASE)
+	return (void *) pa;
 
     panic("pa2kva called with invalid pa 0x%x", pa);
 }
@@ -353,8 +354,9 @@
 kva2pa(void *kva)
 {
     physaddr_t va = (physaddr_t) kva;
-    if (va >= PHYSBASE && va < PHYSEND)
+    if (va >= (uintptr_t) PHYSBASE && va < (uintptr_t) PHYSEND)
 	return va - LOAD_OFFSET;
+
     panic("kva2pa called with invalid kva %p", kva);
 }
 
@@ -369,3 +371,43 @@
 {
     return (pn << PGSHIFT) + PA_MEMBASE;
 }
+
+/*
+ * MMU initialization
+ */
+
+void
+mmu_init(void)
+{
+    uint32_t n2 = 0;
+
+    for (uint32_t i = 64; i < 256; i++) {
+	uint32_t cflag = (i >= 128) ? 0 : PTE_C;
+
+	struct Pagemap2 *pt2 = &bootpt2s[n2++];
+	bootpt.pm1_ent[i] = PTD_ENTRY(kva2pa(pt2));
+
+	for (uint32_t j = 0; j < 64; j++) {
+	    struct Pagemap2 *pt3 = &bootpt2s[n2++];
+	    pt2->pm2_ent[j] = PTD_ENTRY(kva2pa(pt3));
+
+	    for (uint32_t k = 0; k < 64; k++) {
+		uint32_t ppn = i * (1 << 12) + j * (1 << 6) + k;
+		pt3->pm2_ent[k] = (ppn << PTE_PPN_SHIFT) |
+				  (PT_ET_PTE << PT_ET_SHIFT) |
+				  (PTE_ACC_SUPER << PTE_ACC_SHIFT) |
+				  cflag;
+	    }
+	}
+    }
+
+    //assert(n2 == sizeof(bootpt2s) / sizeof(*bootpt2s));
+
+    bootct.ct_ent[0] = (kva2pa(&bootpt) >> 4) | (PT_ET_PTD << PT_ET_SHIFT);
+    sta(SRMMU_CTXTBL_PTR, kva2pa(&bootct) >> 4, ASI_MMUREGS);
+    sta(SRMMU_CTX_REG,    0, ASI_MMUREGS);
+    sta(SRMMU_CTRL_REG,   SRMMU_CTRL_E | lda(SRMMU_CTRL_REG, ASI_MMUREGS),
+			  ASI_MMUREGS);
+    __asm volatile("nop; nop; nop;");
+    tlb_flush_all();
+}
Index: kern/arch/sparc/pmap.h
===================================================================
--- kern/arch/sparc/pmap.h	(revision 6971)
+++ kern/arch/sparc/pmap.h	(working copy)
@@ -22,8 +22,7 @@
     };
 };
 
-extern struct Pagemap bootpt;
-
+void mmu_init(void);
 void page_init(void);
 
 typedef uint32_t ctxptr_t;
@@ -32,8 +31,6 @@
     ctxptr_t ct_ent[CTX_NCTX];
 };
 
-extern struct Contexttable bootct;
-
 #endif /* __ASSEMBLER__ */
 
 #define KSTACK_SIZE	(2 * PGSIZE)
Index: kern/arch/sparc/locore.S
===================================================================
--- kern/arch/sparc/locore.S	(revision 6971)
+++ kern/arch/sparc/locore.S	(working copy)
@@ -18,8 +18,8 @@
 
 	/*
 	 * Disable the MMU, to simplify re-loading a new kernel with grmon.
-	 * This function is also located at 0x80001000, making it easy to
-	 * reset the MMU using "run 0x80001000".
+	 * This function is also located at 0x40001000, making it easy to
+	 * reset the MMU using "run 0x40001000".
 	 */
 	set	SRMMU_CTXTBL_PTR, %g1
 	set	SRMMU_CTX_REG, %g2
@@ -44,34 +44,7 @@
 	set	(PSR_S | PSR_PIL), %g2
 	wr	%g2, %psr
 	WRITE_PAUSE
-		
-	/* Set the first PTD of the Context Table to point to bootpt */
-	set	RELOC(bootpt), %g2 
-	srl	%g2, 4, %g2
-	or	%g2, PT_ET_PTD, %g2
-	set	RELOC(bootct), %g1
-	st	%g2, [%g1]
-
-	/* Set Context Table Pointer register */	
-	srl	%g1, 4, %g1
-	set	SRMMU_CTXTBL_PTR, %g2
-	sta	%g1, [%g2] ASI_MMUREGS
 
-	/* Set context register to 0 */
-	set	SRMMU_CTX_REG, %g2
-	sta	%g0, [%g2] ASI_MMUREGS
-
-	/* Enable MMU */
-	lda	[%g0] ASI_MMUREGS, %g3
-	or	%g3, SRMMU_CTRL_E, %g3
-	sta	%g3, [%g0] ASI_MMUREGS
-	WRITE_PAUSE
-
-	set	vm_enabled, %g1
-	jmpl	%g1, %g0
-	 nop
-
-vm_enabled:	
 	/* Make window 1 invalid */
 	mov	0x02, %wim
 	WRITE_PAUSE
Index: kern/arch/sparc/sparc-config.h
===================================================================
--- kern/arch/sparc/sparc-config.h	(revision 6971)
+++ kern/arch/sparc/sparc-config.h	(working copy)
@@ -12,6 +12,6 @@
  * Based on CONFIG_CLK_MUL, CONFIG_CLK_DIV, in the chip's config.h,
  * starting from BOARD_FREQ (leon3mp.vhd), generated by Xilinx DCM.
  */
-#define CLOCK_FREQ_KHZ	65000
+#define CLOCK_FREQ_KHZ	40000
 
 #endif
Index: kern/arch/sparc/Makefrag
===================================================================
--- kern/arch/sparc/Makefrag	(revision 6971)
+++ kern/arch/sparc/Makefrag	(working copy)
@@ -10,7 +10,6 @@
 KERN_ARCH :=					\
 	$(ARCHDIR)/prom_stage1.S		\
 	$(ARCHDIR)/locore.S			\
-	$(ARCHDIR)/bootdata.c			\
 	$(ARCHDIR)/pmap.c			\
 	$(ARCHDIR)/page.c			\
 	$(ARCHDIR)/reboot.c			\
Index: kern/arch/sparc/bootdata.c
===================================================================
--- kern/arch/sparc/bootdata.c	(revision 6971)
+++ kern/arch/sparc/bootdata.c	(working copy)
@@ -1,50 +0,0 @@
-#include <machine/pmap.h>
-
-/*
- * Boot page tables
- */
-
-#define PTATTR __attribute__ ((aligned (4096), section (".data")))
-#define KPT_BITS ((PT_ET_PTE << PT_ET_SHIFT) | \
-		  (PTE_ACC_SUPER << PTE_ACC_SHIFT))
-
-#define DO_8(_start, _macro)				\
-  _macro (((_start) + 0)) _macro (((_start) + 1))	\
-  _macro (((_start) + 2)) _macro (((_start) + 3))	\
-  _macro (((_start) + 4)) _macro (((_start) + 5))	\
-  _macro (((_start) + 6)) _macro (((_start) + 7))
-
-#define DO_16(_start, _macro)					\
-  DO_8 ((_start) + 0, _macro) DO_8 ((_start) + 8, _macro)
-
-#define DO_64(_start, _macro)					\
-  DO_8 ((_start) + 0, _macro) DO_8 ((_start) + 8, _macro)	\
-  DO_8 ((_start) + 16, _macro) DO_8 ((_start) + 24, _macro)	\
-  DO_8 ((_start) + 32, _macro) DO_8 ((_start) + 40, _macro)	\
-  DO_8 ((_start) + 48, _macro) DO_8 ((_start) + 56, _macro)
-
-#define TRANS16MEG_C(n) \
-    (PTE_C | KPT_BITS | (((0x1000000UL * (n)) >> PGSHIFT) << PTE_PPN_SHIFT)),
-#define TRANS16MEG_NC(n) \
-    (KPT_BITS | (((0x1000000UL * (n)) >> PGSHIFT) << PTE_PPN_SHIFT)),
-
-/*
- * See memlayout.h for kernel memory layout.
- */
-struct Pagemap bootpt PTATTR = {
-  .pm1_ent = {
-    [64] = DO_64(64, TRANS16MEG_C)
-    [128] = DO_64(64, TRANS16MEG_C)
-    [224] = DO_16(128, TRANS16MEG_NC)
-    [240] = DO_16(240, TRANS16MEG_NC)
-  }
-};
-
-/*
- * Context table, inited during boot
- */
-#define CTATTR __attribute__ ((aligned (4096), section (".data")))
-struct Contexttable bootct CTATTR;
-
-struct Trapcode idt[0x100];
-
