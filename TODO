in-kernel segment COW: beware of DMA (watch for ko->ko_pin_pg)

page reclamation, LRU
deal with segment fragmentation on-disk

lwip: fix sys_arch_timeouts() in lib/lwip/jos64/arch/sys_arch.c; need to
have a callback of some sort for when threads enter/leave an AS.

associate DMA/PTE pinning with physical pages rather than kobjects.
currently only one address space can have a page in a PTE while it's
being written out to disk -- the second AS that tries to fault it in
goes to sleep because we don't know if it's safe to COW!

min/max labels on MLT to control contamination

MT-safe c++ support (lib/cppsup/bits/gthr.h)

sys_thread_sync_wait() should invert page-addr into segment+offset

netd_server doesn't do any checking on who's asking for what fd.
socket() should grant a handle at * to the caller that will let
them later do other socket operations.

better separation between kernel, user-space and shared header files

how to expose thread-local container and segment?  is it safe?

expose kobj_label's at the syscall API to get label sharing

better MLT support in the filesystem: unification et al

===

multiple threads that have different labels in the same AS is a little
strange.  when you want to give an fd to another thread, you have to
grant it fd handles at *; similarly, when you close an fd, you should
make sure no other thread has those handles at * (otherwise they'll
never get GCed from the label).  maybe it makes sense to have some
sort of label shared by threads that goes along with an AS?

for discretionary handles (at *) we could implement this at user-space,
by using lib/privstore.cc to stash away/drop privilege.  for handles
at non-* levels, this might be a non-issue?

===

store all * handles in a privstore; thread label *'s is a cache..

===

fix netd bug (fetch'ing files hangs for some files but not others)

also need to figure out how to specify which capability-like *-handles to pass
across fork/exec/spawn.  e.g. want to pass unix-user *-handles when spawning
processes, but not your process taint/grant handles.

thread halt-and-copy
proper accounting for object label size
user-space resource allocators

fsync, sync, reboot

unix users as handles -- integrate/extend the existing authd strawman?

make jos64 a usable environment:
 * gcc/binutils
 * some sort of editor (nvi, nano, ..)
 * tetex

system management in a fully-persistent world
 * restarting services (how does it interact with handles & gates?)
 * upgrades (signing binaries => integrity handles)

split the gate clearance into clearance & verify labels.

console FD is not writable by most processes but they want to hard-link it.
what of our rule that you cannot hard-link a segment without being able to write it?
can workaround in this case by using the existing console FD from another container.

we seem to have a potential confused deputy problem with our file access
mechanism..  how do you access a file using only a subset of your credentials?

more aggressive labeling:
 - netd args segment should be labeled with gate-call handle.
 - taint_ct in gate_call/gate_return should be labeled with gate-call handle.

growing stacks would be nice; gnu programs like stack space, but it's a waste
to keep a statically-sized huge stack.

