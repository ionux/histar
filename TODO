Compatibility issues:

* integrate authd, make "real" unix users
* thread-safe uclibc
* call destructors in longjmp (see how linux/glibc does it?)
* MT-safe c++ support (lib/cppsup/bits/gthr.h)

Performance:

* reasonable select() implementation
* deal with fragmentation on-disk
* partial segment swapin and swapout
* page reclamation, LRU (unpin callbacks for reclaiming space?)

Kernel bugs:

Security:

* netd_server doesn't do any checking on who's asking for what fd.
  socket() should grant a handle at * to the caller that will let
  them later do other socket operations.
* taint_ct in gate_call/gate_return should be labeled with gate-call handles.
* library call to run with a subset of your privileges, for doing some
  operation on behalf of the caller (e.g. in the declassifier gate).
* should be more careful in dealing with segments passed in via gates; namely,
  need to avoid page faults, and ensure that we access them only with caller's
  privileges (verify label).  can arise for two reasons: first, we map the segment
  into our AS but don't have the privilege to read or write to it.  this can be
  fixed by segment_map() checking the label.  second, the other side can drop the
  segment and the service (other side of gate) will fault because the segment is
  gone.  for this, need either to copy all segments first, or to have a careful-read
  and careful-write wrapper that does setjmp() first, and the segfault handler will
  longjmp().

Cleanup:

* expose CPU resource allocation: track resources in container entries and
  re-compute a thread's th_sched_tickets when it changes its label to only
  include resources from containers it can read.
* better separation between kernel, user-space and shared header files
* user-space resource allocators -- i.e. running without CT_QUOTA_INF
* (?) expose kobj_label's at the syscall API to get label sharing
* lwip: fix sys_arch_timeouts() in lib/lwip/jos64/arch/sys_arch.c;
  need a callback for when threads enter/leave an AS.
* sys_reboot()
* split the pstate sync timestamp counter from the handle counter
* enforce clearance allocation bound
* netd_select gate asks for a non-tls stack but doesn't addref the thread,
  which means its non-tls stack will not get cleaned up if the thread dies

Bugs:

* netd bug (fetch'ing files hangs for some files but not others)
* bugs in handling out-of-memory conditions
* look for concurrency bugs using test harness (make disk ops async)
* utrap TLS bug (easy to walk over stack...gate calls, switch stack
  then a trap...)

Larger issues:

* backup/restore
* system management in a fully-persistent world:
  - restarting services with handles and gates
  - upgrades (signing binaries => integrity handles?)

New hardware support:

* hyperthreading/multicore: use monitor/mwait or pause/spinwait for
  fast sys-/vmm-calls.
* debug registers: use call tracing for kernel debugging?
  intel CPUs have 16-slot buffers it seems, while AMD traps on every jmp.
* iommu: device drivers into user-mode.  some more thoughts on hardcopy paper.
* cpu virt: containerize SMM (do any desktops use SMM much?  usb kbd virt?)
* cpu virt: move parts of the current CPL=0 kernel into a VMM ("ring -1")
  and make the CPL=0 code less trusted.
* use ata "nv cache" (flash memory) feature set to speed up disk sync.

Miscellaneous:

===

multiple threads that have different labels in the same AS is a little
strange.  when you want to give an fd to another thread, you have to
grant it fd handles at *; similarly, when you close an fd, you should
make sure no other thread has those handles at * (otherwise they'll
never get GCed from the label).  maybe it makes sense to have some
sort of label shared by threads that goes along with an AS?

for discretionary handles (at *) we could implement this at user-space,
by using lib/privstore.cc to stash away/drop privilege.  for handles
at non-* levels, this might be a non-issue?

possible answer: store all stars in a privstore; stars in thread label
are a cache.  how to catch -E_LABEL errors and how to fetch the right
handle?

===

also need to figure out how to specify which capability-like *-handles to pass
across fork/exec/spawn.  e.g. want to pass unix-user *-handles when spawning
processes, but not your process taint/grant handles.

===

