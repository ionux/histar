threads as 1-slot (or few-slot) containers

what are the right label rules for containers?  consider an
example of a gate that needs to store COW segments for different
contaminations.  in what container could it store these segments,
and where would that container itself be stored?

user-specified segment labeling
in-kernel segment copying
user-specified container labeling
larger labels

ne2k driver

multiplexing between potentially different network adapters
label checking for network buffers

type-check for correct info_flow_type values (easier in C++)

C type-safety for enums/int-typedefs: wrap in a struct

* it would be nice if gate_enter() didn't automatically compute the
  contamination, but allowed the user to compute the target label
  and verified that it's OK.  benefit: easier to make return gate.
  is it OK to allow user to look at the gate's target label?
  looks like yes..

implement MLTs
do COW in gate_enter_locked()
use MLTs to store COW mappings in gate_enter for later reuse

kernel waiting primitive: sys_wait_for_equal(int *ptr, int val)

copy-on-write kobjects
page reclamation, LRU
snapshotting pstate_sync()
pin segment pages that are referenced in page maps

deal with segment fragmentation on-disk

