user-specified segment labeling
in-kernel segment copying
user-specified container labeling
larger labels

segment_maps are value objects, and thus aren't so amenable to sharing.
in particular, you can't have threads with shared mutable address space.

irq_register
multiplexing between potentially different network adapters
make sure net works after system restart (bufs get removed from rings)
label checking for network buffers

type-check for correct info_flow_type values (easier in C++)

C type-safety for enums/int-typedefs: wrap in a struct

* it would be nice if gate_enter() didn't automatically compute the
  contamination, but allowed the user to compute the target label
  and verified that it's OK.  benefit: easier to make return gate.
  is it OK to allow user to look at the gate's target label?

* what to do about writable segments and contaminated gate entry?
  in particular, the segment must be COW'ed, but what to name it?
  possible that this could all be done at user-level by clever
  gate-entry code (first map a stack using registers, then can do
  C code).

implement MLTs

kernel sleep primitive: sys_sleep_until_equal(int *ptr, int val)

copy-on-write kobjects
kobject pinning, page reclamation, LRU
snapshotting pstate_sync()
swapped-out zero-ref objects are never GC'ed

deal with segment fragmentation on-disk

what happens when we suspend cur_thread via thread_pagefault()
when we really incurred the fault in kernel-mode through a
syscall pointer argument?

