in-kernel segment COW: beware of DMA (watch for ko->ko_pin_pg)

page reclamation, LRU
deal with segment fragmentation on-disk

lwip: fix sys_arch_timeouts() in lib/lwip/jos64/arch/sys_arch.c; need to
have a callback of some sort for when threads enter/leave an AS.

associate DMA/PTE pinning with physical pages rather than kobjects.
currently only one address space can have a page in a PTE while it's
being written out to disk -- the second AS that tries to fault it in
goes to sleep because we don't know if it's safe to COW!

make the mount table a separate segment that can be shared

min/max labels on MLT to control contamination

MT-safe c++ support (lib/cppsup/bits/gthr.h)

sys_thread_sync_wait() should invert page-addr into segment+offset

netd_server doesn't do any checking on who's asking for what fd.
socket() should grant a handle at * to the caller that will let
them later do other socket operations.

gate caveat: whenever you call a low-clearance gate (e.g. { x0 3 }, like
a return gate), the target clearance is probably going to be too low.
should remember to reset your clearance higher before doing much else.

better separation between kernel, user-space and shared header files

how to expose thread-local container and segment?  is it safe?

expose kobj_label's at the syscall API to get label sharing

better MLT support in the filesystem: unification et al

floating point context switching support -- grow the thread kobject?

===

multiple threads that have different labels in the same AS is a little
strange.  when you want to give an fd to another thread, you have to
grant it fd handles at *; similarly, when you close an fd, you should
make sure no other thread has those handles at * (otherwise they'll
never get GCed from the label).  maybe it makes sense to have some
sort of label shared by threads that goes along with an AS?

for discretionary handles (at *) we could implement this at user-space,
by using lib/privstore.cc to stash away/drop privilege.  for handles
at non-* levels, this might be a non-issue?

===

store all * handles in a privstore
 - pending more discussion on thread signaling label rules (thread groups?)

===

fix netd bug (fetch'ing files hangs for some files but not others)

tun/tap driver for openvpn
allow multiple netd's (specify netd gate in fd_sock)
tun/tap-backed interface for lwip
vpn netd

how to integrate tainting with the shell?  maybe something along these lines:
  sh% run_tainted vpn_red sh
  vpn_red% .. running as { vpn_red:2 1 }
  vpn_red% declassify_exit
  sh% run_tainted vpn_green sh
  vpn_green% .. running as { vpn_green:2 1 }
  vpn_green% declassify_exit
  sh% 
also need to figure out how to specify which capability-like *-handles to pass
across fork/exec/spawn.  e.g. want to pass unix-user *-handles when spawning
processes, but not your process taint/grant handles.

container resource limits
thread halt-and-copy
non-resizable segments

user-space resource allocators

how to deal with system calls returning E_RESOURCE?  every call to be checked?

fsync, sync, reboot

unix users as handles -- integrate/extend the existing authd strawman?

make jos64 a usable environment:
 * gcc/binutils
 * some sort of editor (nvi, nano, ..)
 * tetex

system management in a fully-persistent world
 * restarting services (how does it interact with handles & gates?)
 * upgrades (signing binaries => integrity handles)

