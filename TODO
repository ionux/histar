user-specified segment labeling
in-kernel segment copying
user-specified container labeling
larger labels

segment_maps are value objects, and thus aren't so amenable to sharing.
in particular, you can't have threads with shared mutable address space.

irq_register
multiplexing between potentially different network adapters
label checking for network buffers

IPC

sockets API -- probably IPC to netd?

type-check for correct info_flow_type values (easier in C++)

C type-safety for enums/int-typedefs: wrap in a struct

* it would be nice if gate_enter() didn't automatically compute the
  contamination, but allowed the user to compute the target label
  and verified that it's OK.  benefit: easier to make return gate.
  is it OK to allow user to look at the gate's target label?

* what to do about writable segments and contaminated gate entry?
  in particular, the segment must be COW'ed, but what to name it?
  possible that this could all be done at user-level by clever
  gate-entry code (first map a stack using registers, then can do
  C code).

implement MLTs

kernel waiting primitive: sys_wait_for_equal(int *ptr, int val)

copy-on-write kobjects
page reclamation, LRU
snapshotting pstate_sync()
pin segment pages that are referenced in page maps

deal with segment fragmentation on-disk

what happens when we suspend cur_thread via thread_pagefault()
when we really incurred the fault in kernel-mode through a
syscall pointer argument?

