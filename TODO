think more about argument passing across gate calls & returns;
in the current scheme with argument segments, who unrefs them,
and will they have a thread label sufficient to do the unref?
[ possible answer: call back into gate to "free" the buffer? ]
[ possible answer2: thread can hold a reference on one object,
  and this would be the argument passed across call/return ]

user-specified segment labeling
in-kernel segment copying
user-specified container labeling
larger labels

segment_maps are value objects, and thus aren't so amenable to sharing.
in particular, you can't have threads with shared mutable address space.

ne2k driver

multiplexing between potentially different network adapters
label checking for network buffers

type-check for correct info_flow_type values (easier in C++)

C type-safety for enums/int-typedefs: wrap in a struct

* it would be nice if gate_enter() didn't automatically compute the
  contamination, but allowed the user to compute the target label
  and verified that it's OK.  benefit: easier to make return gate.
  is it OK to allow user to look at the gate's target label?

implement MLTs
do COW in gate_enter_locked()
use MLTs to store COW mappings in gate_enter for later reuse

kernel waiting primitive: sys_wait_for_equal(int *ptr, int val)

copy-on-write kobjects
page reclamation, LRU
snapshotting pstate_sync()
pin segment pages that are referenced in page maps

deal with segment fragmentation on-disk

