think more about argument passing across gate calls & returns;
in the current scheme with argument segments, who unrefs them,
and will they have a thread label sufficient to do the unref?
[ possible answer: call back into gate to "free" the buffer? ]

user-specified segment labeling
in-kernel segment copying
user-specified container labeling
larger labels

segment_maps are value objects, and thus aren't so amenable to sharing.
in particular, you can't have threads with shared mutable address space.

irq_register
multiplexing between potentially different network adapters
label checking for network buffers

type-check for correct info_flow_type values (easier in C++)

C type-safety for enums/int-typedefs: wrap in a struct

* it would be nice if gate_enter() didn't automatically compute the
  contamination, but allowed the user to compute the target label
  and verified that it's OK.  benefit: easier to make return gate.
  is it OK to allow user to look at the gate's target label?

* what to do about writable segments and contaminated gate entry?
  in particular, the segment must be COW'ed, but what to name it?
  possible that this could all be done at user-level by clever
  gate-entry code (first map a stack using registers, then can do
  C code).

  possible solution: stick a mutex (atomic_t) on the entry stack,
  lock the mutex from asm without using the stack, then the rest
  of the gate entry code maps a new stack, does whatever COW ops,
  then jumps to new stack and unlocks the entry stack.

implement MLTs

kernel waiting primitive: sys_wait_for_equal(int *ptr, int val)

copy-on-write kobjects
page reclamation, LRU
snapshotting pstate_sync()
pin segment pages that are referenced in page maps

deal with segment fragmentation on-disk

