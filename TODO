threads should not have refcounts -- switch ownership on gate call?
the mutable label leaks information.

thread containers should not be nameable by container ID,
and should not allow sub-containers or sub-threads.  probably
a container should have a list of allowable objects, and the
thread-specific containers won't allow containers or threads.

in-kernel segment COW: beware of DMA (watch for ko->ko_pin_pg)
user-specified container labeling

* it would be nice if gate_enter() didn't automatically compute the
  contamination, but allowed the user to compute the target label
  and verified that it's OK.  benefit: easier to make return gate.
  is it OK to allow user to look at the gate's target label?
  looks like yes..

do COW in gate_enter()
use MLTs to store COW mappings in gate_enter for later reuse

kernel waiting primitive: sys_wait_for_equal(int *ptr, int val)

page reclamation, LRU
deal with segment fragmentation on-disk

do page-faulting threads always terminate?  e.g. write to unwritable page..

lwip: fix sys_arch_timeouts() in lib/lwip/jos64/arch/sys_arch.c; need to
have a callback of some sort for when threads enter/leave an AS.

associate DMA/PTE pinning with physical pages rather than kobjects.
currently only one address space can have a page in a PTE while it's
being written out to disk -- the second AS that tries to fault it in
goes to sleep because we don't know if it's safe to COW!

some sort of disk queueing, or proper interlocking.  currently swapout
can prevent swapin from scheduling its disk request, which suspends the
requesting thread indefinitely.

scatter-gather/iovec interface to disk_io() so that we can write out
the entire object (or at least 64K worth of pages) in one request.

