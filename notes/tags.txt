What should happen on trap to monitor mode?
    Disable traps [done in hw]
    Disable MMU [not done in hw yet]

We need to be careful with MMU state when doing protected calls.
    Put the MMU into a well-known state before switching PC tags

Control who can invoke what protection domains, and with what tags.
    Global authorized dispatch table?

What should be the rules for combining privileges on protected calls?
    Might need to merge privileges of caller & callee
    Can emulate any behavior we want in software..

Can potentially make the memory allocator untrusted by allowing memory
    re-tagging ala Mondrix.

Go through and minimize the number of __krw__/DTAG_KRW variables that
    are globally-writable, by adding protection domains.

Will probably need to know the caller's tag for some operations
    (e.g. allocate memory on caller's behalf)

Need a way to securely track kernel objects (special dtag values),
    and prevent non-monitor code from tag_set'ing memory to that
    dtag value..

When can you read tags?  Might be safe to always allow it, or can
    read tags only when you can read data as well.  On the other
    hand, only the monitor (TSR_T) can write tags.

Should jump to another protection domain to handle device interrupts,
    to reduce effective TCB for non-interrupt (i.e. real user data)
    protection domains.

Thread wait/run lists: not a big deal if they are screwed up, basically
    a denial of service attack on some thread.  We do, however, need to
    make sure we are dealing with authentic Thread object pointers, so
    that we don't get fooled into poking around in private data.

    Should implement type-safe LIST/TAILQ macros that automatically do
    the right checks..  Need to be careful about next/prev pointers when
    inserting or removing items, in addition to checks when traversing.

    To check, either verify tag of all words, or tag of first word and
    proper alignment (e.g. page aligned kobjects).

What about refcounts?  Who enforces them?
    For now, we punt on securing refcounts.  Unfortunately this means
    that attackers can drop refcounts for high-integrity stuff..

Labels:
    - Label object is KRW until used for a tag
    - At that point, change the whole label to be KRO to finalize it
      - Keep the ko_id as DTAG_KOBJ, ko_ref as DTAG_KRW

Subset of remaining issues:
    - Kobject GC / page_free()
    - Label/clearance changes, category allocation
    - Gate calls
    - Label integrity
    - Cached page tables for AS

Done:
    + Gate, thread allocation [clearance]: kobject_alloc takes clearance

		Set T	Set S
Tag exception	YES	YES
Other exception	NO	YES

=> Need to preload access bits for kernel text, kernel stack,
   because we cannot handle tag exceptions in kernel window
   exception handling code.

