What should happen on trap to monitor mode?
    Disable traps [done in hw]
    Disable MMU [not done in hw yet]

We need to be careful with MMU state when doing protected calls.
    Put the MMU into a well-known state before switching PC tags

Control who can invoke what protection domains, and with what tags.
    Global authorized dispatch table?

What should be the rules for combining privileges on protected calls?
    Might need to merge privileges of caller & callee
    Can emulate any behavior we want in software..

Can potentially make the memory allocator untrusted by allowing memory
    re-tagging ala Mondrix.

Go through and minimize the number of __krw__/DTAG_KRW variables that
    are globally-writable, by adding protection domains.

Will probably need to know the caller's tag for some operations
    (e.g. allocate memory on caller's behalf)

Need a way to securely track kernel objects (special dtag values),
    and prevent non-monitor code from tag_set'ing memory to that
    dtag value..

When can you read tags?  Might be safe to always allow it, or can
    read tags only when you can read data as well.  On the other
    hand, only the monitor (TSR_T) can write tags.

Should jump to another protection domain to handle device interrupts,
    to reduce effective TCB for non-interrupt (i.e. real user data)
    protection domains.

Thread wait/run lists: not a big deal if they are screwed up, basically
    a denial of service attack on some thread.  We do, however, need to
    make sure we are dealing with authentic Thread object pointers, so
    that we don't get fooled into poking around in private data.

    Should implement type-safe LIST/TAILQ macros that automatically do
    the right checks..  Need to be careful about next/prev pointers when
    inserting or removing items, in addition to checks when traversing.

    To check, either verify tag of all words, or tag of first word and
    proper alignment (e.g. page aligned kobjects).

What about refcounts?  Who enforces them?
    For now, we punt on securing refcounts.  Unfortunately this means
    that attackers can drop refcounts for high-integrity stuff..

Labels:
    - Label object is KRW until used for a tag
    - At that point, change the whole label to be KRO to finalize it
      - Keep the ko_id as DTAG_KOBJ, ko_ref as DTAG_KRW

Subset of remaining issues:
    - Label integrity
    - Cached page tables for AS

Done:
    + Gate, thread allocation [clearance]: kobject_alloc takes clearance
    + Label/clearance changes, category allocation
    + Gate calls
    + Kobject GC / page_free(): run GC with pctag=object-label
    + Need to avoid purging PC tags that are in use or up the stack
    + Pin data tag / PC tag labels so they don't get GCed underneath us

		Set T	Set S
Tag exception	YES	YES
Other exception	NO	YES

=> Need to preload access bits for kernel text, kernel stack,
   because we cannot handle tag exceptions in kernel window
   exception handling code.

===

Ensure refcount integrity: tag every refcount-holder (kobject_id_t) with
a special tag value that indicates this is a refcount + whose refcount
it is.  So, a combination tag that refers to a label + a flag to indicate
a refcount value.  Monitor does addref/incref and GC on 0.  Containers
should be changed so the slot is just a uint64_t with no internal refcount.

Make sure page_free() refuses to take a kobject.

Disk: two alternatives:

 - Object integrity but not integrity of lookup mechanism.
   Requires tagging sectors but btree is untrusted and malicious
   kernel code can make an object ID unreachable.

 - Use flash to implement a much simpler object ID to disk address
   mapping mechanism using a simple hash table much like in memory.
   Trusted (but simple) hash table code.  Must still keep sector
   tags to manage free list and data labels.

