#include <machine/pmap.h>
#include <machine/types.h>
#include <dev/kclock.h>
#include <kern/lib.h>
#include <kern/pageinfo.h>
#include <kern/arch.h>
#include <inc/error.h>
#include <inc/queue.h>

static bool_t scrub_free_pages = 0;

// These variables are set by i386_detect_memory()
static physaddr_t maxpa;	// Maximum physical address
uint64_t global_npages;		// Amount of physical memory (in pages)
static size_t basemem;		// Amount of base memory (in bytes)
static size_t extmem;		// Amount of extended memory (in bytes)

// These variables are set in i386_vm_init()
static char *boot_freemem;	// Pointer to next byte of free mem

struct Page_link {
    TAILQ_ENTRY(Page_link) pp_link;	// free list link
};
static TAILQ_HEAD(Page_list, Page_link) page_free_list;
				// Free list of physical pages

// Global page allocation stats
struct page_stats page_stats;

// Keep track of various page metadata
struct page_info *page_infos;

static int
nvram_read(int r)
{
    return mc146818_read (r) | (mc146818_read (r + 1) << 8);
}

static void
i386_detect_memory(uint64_t lower_kb, uint64_t upper_kb)
{
    // Worse case, CMOS tells us how many kilobytes there are
    if (!lower_kb)
	lower_kb = nvram_read(NVRAM_BASELO);
    if (!upper_kb)
	upper_kb = nvram_read (NVRAM_EXTLO);

    basemem = ROUNDDOWN(lower_kb * 1024, PGSIZE);
    extmem  = ROUNDDOWN(upper_kb * 1024, PGSIZE);

    // Calculate the maxmium physical address based on whether
    // or not there is any extended memory.  See comment in ../inc/mmu.h.
    if (extmem)
	maxpa = EXTPHYSMEM + extmem;
    else
	maxpa = basemem;

    global_npages = maxpa / PGSIZE;

    cprintf("Physical memory: %dK available, ", (int) (maxpa / 1024));
    cprintf("base = %dK, extended = %dK\n", (int) (basemem / 1024),
	    (int) (extmem / 1024));
}

//
// Allocate n bytes of physical memory aligned on an 
// align-byte boundary.  Align must be a power of two.
// Return kernel virtual address.  Returned memory is uninitialized.
//
// If we're out of memory, boot_alloc should panic.
// It's too early to run out of memory.
// This function may ONLY be used during initialization,
// before the page_free_list has been set up.
// 
static void *
boot_alloc(uint32_t n, uint32_t align)
{
  extern char end[];
  void *v;

  // Initialize boot_freemem if this is the first time.
  // 'end' is a magic symbol automatically generated by the linker,
  // which points to the end of the kernel's bss segment -
  // i.e., the first virtual address that the linker
  // did _not_ assign to any kernel code or global variables.
  if (boot_freemem == 0)
    boot_freemem = end;

  boot_freemem = (char *) ROUNDUP (boot_freemem, align);
  if (boot_freemem + n < boot_freemem
      || boot_freemem + n > (char *) (maxpa + KERNBASE))
    panic ("out of memory during i386_vm_init");
  v = boot_freemem;
  boot_freemem += n;
  return v;
}

void
page_free(void *v)
{
    struct Page_link *pl = (struct Page_link *) v;
    if (PGOFF(pl))
	panic("page_free: not a page-aligned pointer %p", pl);

    if (scrub_free_pages)
	memset(v, 0xde, PGSIZE);

    TAILQ_INSERT_TAIL(&page_free_list, pl, pp_link);
    page_stats.pages_avail++;
    page_stats.pages_used--;
}

int
page_alloc(void **vp)
{
    struct Page_link *pl = TAILQ_FIRST(&page_free_list);
    if (pl) {
	TAILQ_REMOVE(&page_free_list, pl, pp_link);
	*vp = pl;
	page_stats.pages_avail--;
	page_stats.pages_used++;
	page_stats.allocations++;

	if (scrub_free_pages)
	    memset(pl, 0xcd, PGSIZE);

	return 0;
    }

    cprintf("page_alloc: returning no mem\n");
    page_stats.failures++;
    return -E_NO_MEM;
}

void
page_init(uint64_t lower_kb, uint64_t upper_kb)
{
    i386_detect_memory(lower_kb, upper_kb);
    TAILQ_INIT(&page_free_list);

    int inuse;

    // Align boot_freemem to page boundary.
    boot_alloc(0, PGSIZE);

    // Allocate space for page status info.
    uint64_t sz = global_npages * sizeof(*page_infos);
    page_infos = boot_alloc(sz, PGSIZE);
    memset(page_infos, 0, sz);

    // Align to another page boundary.
    boot_alloc(0, PGSIZE);

    for (uint64_t i = 0; i < global_npages; i++) {
	// Off-limits until proven otherwise.
	inuse = 1;

	// The bottom basemem bytes are free except page 0.
	if (i != 0 && i < basemem / PGSIZE)
	    inuse = 0;

	// The IO hole and the kernel abut.

	// The memory past the kernel is free.
	if (i >= RELOC (boot_freemem) / PGSIZE)
	    inuse = 0;

	if (!inuse)
	    page_free(pa2kva(i << PGSHIFT));
    }

    page_stats.pages_used = 0;
}
